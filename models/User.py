#! /bank/bin/python
from flask import Flask, jsonify, session, request, redirect
from argon2 import PasswordHasher
from datetime import datetime
from . import database as db
from uuid import uuid4
import re

user_accounts = db.client["bank"]["accounts"]
one_time_passwords = db.client["bank"]["oneTimePasswords"]


class User:
    def start_session(self, user):
        del user["password"], user["transactions"]
        session["logged_in"] = True
        session["user"] = user
        return jsonify(user), 200

    def signout(self):
        session.clear()
        return redirect("/")

    def login(self):
        """
        Locating user by email account provided in the form,
        In case the user account is found, password is compared with the hashed version in the database.
        Will either call a function session_start or inform the user that incorrect login credentials were provided.
        """
        user = user_accounts.find_one({"email": request.form.get("email")})
        one_time_password = one_time_passwords.find_one({"_id": user["_id"]})

        if user is not None:
            if one_time_password and self.verify_password(one_time_password["oneTimePassword"], request.form.get("password")):
                self.start_session(user)
                return jsonify({"changePassword": 1}), 200
            if self.verify_password(user["password"], request.form.get("password")):
                return self.start_session(user)
        return jsonify({"error": "Invalid login credentials"}), 401

    def signup(self):
        """
        User ID is generated by using the current date and time and adding uuid4
        Account is created with a starting transaction which is deposit from the bank.
        In case user is created succesfully, session is started.
        """
        if request.form.get("password") != request.form.get("confirm_password"):
            return jsonify({"error": "Passwords did not match"}), 400
        if not self.valid_password(request.form.get("password")):
            return jsonify({"error": "Password does not meet the minimum criteria. It has to contain minimum of 8 characters, a-z, A-Z, 0-9, includes _, @ or $"}), 400
        user_id = datetime.now().strftime("%Y%m-%d%H-%M%S-") + str(uuid4())
        user = {
            "_id": user_id,
            "first_name": request.form.get("first_name"),
            "last_name": request.form.get("last_name"),
            "age": request.form.get("age"),
            "username": request.form.get("username"),
            "country": "Denmark",
            "email": request.form.get("email"),
            "phone_number": request.form.get("phone_number"),
            "balance": 9.99,
            "password": PasswordHasher().hash(request.form.get("password")),
            "interest_rate": 0.03,
            "interest_earned": 0,
            "transactions": {
                datetime.now().strftime("%Y%m-%d%H-%M%S-")
                + str(uuid4()): {
                    "type": "Deposit",
                    "sender": "Honey Bank",
                    "sender_id": "Honey Bank",
                    "receiver": " ".join(
                        [request.form.get("first_name"), request.form.get("last_name")]
                    ),
                    "receiver_id": user_id,
                    "amount": 9.99,
                    "date": str(datetime.now())[0:-7],
                    "end_balance": 9.99,
                }
            },
        }

        if user_accounts.find_one({"email": user["email"]}):
            return jsonify({"error": "Email address is already in use"}), 400
        if user_accounts.find_one({"username": user["username"]}):
            return jsonify({"error": "Username is already in use"}), 400
        user_accounts.insert_one(user)
        return self.start_session(user)

    def change_password(self, id, password, password_confirmation):
        """
        Changing the password of user account.
        Used both for forgot password and password change in account.
        """
        if password != password_confirmation:
            return jsonify({"error": "Passwords do not match."}), 400
        if not self.valid_password(password):
            return jsonify({"error": "Password does not meet the minimum criteria. It has to contain minimum of 8 characters, a-z, A-Z, 0-9, includes _, @ or $"}), 400
        newPassword = PasswordHasher().hash(password)
        current_user = user_accounts.find_one({"_id":id})
        user_accounts.update_one(current_user, {
                "$set": {
                    "password": newPassword,
                }
            },)

        return jsonify({"success": "Password changed succesfully."}), 200
        


    def get_overview(self, id):
        """
        Return list of details to display on the dashboard.
        Calculates income, expenses for current month.
        """
        transactions_list = user_accounts.find_one({"_id": str(id)})["transactions"]
        income_this_month = expenses_this_month = 0.00
        current_month = datetime.now().month
        transactions = list(transactions_list.values())
        for each in transactions[::-1]:
            amount = each["amount"]
            month = datetime.strptime(each["date"], "%Y-%m-%d %H:%M:%S").month
            if month == current_month:
                if each["sender_id"] == str(id):
                    expenses_this_month += amount
                else:
                    income_this_month += amount
            else:
                break
        return (transactions_list, income_this_month, expenses_this_month)


    def verify_password(self, hash, password):
        try:
            PasswordHasher().verify(hash, password)
            return True
        except:
            return False

    def valid_password(self, password):
        requirements = re.compile(r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!#%*?&]{8,20}$')
        return True if requirements.fullmatch(password) else False